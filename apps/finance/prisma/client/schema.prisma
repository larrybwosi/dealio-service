generator client {
  provider        = "prisma-client-js"
  output          = "../prisma/client"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Core Models ---

model User {
  id                   String         @id @default(cuid())
  name                 String?
  email                String         @unique
  password             String?
  role                 UserRole       @default(MEMBER)
  isActive             Boolean        @default(true)
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  emailVerified        Boolean?
  image                String?
  banned               Boolean?
  banReason            String?
  banExpires           DateTime?
  username             String?
  accounts             Account[]
  members              Member[]
  invitations          Invitation[]
  sessions             Session[]
  activeOrganizationId String?
  notifications        Notification[]
  expenseNotifications Notification[] @relation("UserExpenseNotifications")
  displayUsername      String?
  apikeys              Apikey[]

  // Referral System Fields
  referralCode  String?    @unique
  referrerId    String?
  referrer      User?      @relation("UserReferrer", fields: [referrerId], references: [id], onDelete: SetNull)
  referees      User[]     @relation("UserReferrer")
  referralsMade Referral[] @relation("ReferredBy")
  referredBy    Referral?  @relation("ReferredUser")

  @@unique([username])
  @@map("user")
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  DEVELOPER
  CLIENT
  MEMBER
  CUSTOMER
}

enum MemberRole {
  OWNER // Full control over the organization
  ADMIN // Can manage most aspects, except billing/org deletion
  MANAGER // Can manage day-to-day operations (sales, inventory, staff)
  EMPLOYEE // Standard user, can perform assigned tasks (e.g., make sales, receive stock)
  CASHIER // Limited role, primarily for making sales
  REPORTER // View-only access to reports
  CUSTOMER // Can access customer portal, view own data
  GUEST // Add GUEST role for temporary external users
}

model Organization {
  id           String   @id @default(cuid())
  name         String
  slug         String   @unique
  logo         String?
  description  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  customFields Json?
  email        String?
  phone        String?
  address      String?

  defaultLocationId  String?
  defaultWarehouseId String?

  members              Member[]
  invitations          Invitation[]
  customers            Customer[]
  categories           Category[]
  products             Product[]
  suppliers            Supplier[]
  sales                Sale[]
  orders               Order[]
  purchases            Purchase[]
  returns              Return[]
  stockBatches         StockBatch[]
  inventoryLocations   InventoryLocation[]
  productVariantStocks ProductVariantStock[]
  stockAdjustments     StockAdjustment[]
  stockMovements       StockMovement[]
  cashDrawers          CashDrawer[]
  loyaltyTransactions  LoyaltyTransaction[]
  attachments          Attachment[]
  auditLogs            AuditLog[]
  settings             OrganizationSettings?
  executionLogs        ExecutionLog[]
  notifications        Notification[]

  // New relations for storage management
  storageZones     StorageZone[]
  storageUnits     StorageUnit[]
  storagePositions StoragePosition[]

  // Expense management relations
  expenses          Expense[]
  budgets           Budget[]
  recurringExpenses RecurringExpense[]
  expenseApprovals  ExpenseApproval[]
  budgetAlerts      BudgetAlert[]
  departments       Department[]

  expenseCategories        ExpenseCategory[]
  expenseApprovalRequired  Boolean           @default(false) // Whether expenses require approval
  expenseApprovalThreshold Decimal?          @db.Decimal(10, 2) // Amount above which approval is required
  expenseReceiptRequired   Boolean           @default(true) // Whether receipts are mandatory
  expenseReceiptThreshold  Decimal?          @db.Decimal(10, 2) // Amount above which receipt is required

  activeExpenseWorkflowId String?
  activeExpenseWorkflow   ApprovalWorkflow? @relation("ActiveOrgWorkflow", fields: [activeExpenseWorkflowId], references: [id], onDelete: SetNull)

  // Relation to all workflows defined for this org
  approvalWorkflows        ApprovalWorkflow[] @relation("OrgWorkflows")
  expenseApprovalWorkflows ApprovalWorkflow[] @relation("ExpenseApprovalWorkflows")
  defaultExpenseCurrency   String             @default("USD")
  expenseTagOptions        String[]
  assistants               Assistant[]
  assistantLogs            AssistantLog[]

  // Accounting related relations
  accounts      FinancialAccount[]
  journals      Journal[]
  fiscalPeriods FiscalPeriod[]
  accountTypes  AccountType[]

  mpesaPaymentRequests MpesaPaymentRequest[]
  attendanceLogs       AttendanceLog[]
  taxes                Tax[]
  channels             Channel[] // Channels for chat functionality
  customRoles          CustomRole[]
  reports              Report[]
  backups              Backup[]
  Subscription         Subscription?
  referrals            Referral[]
  loyaltyProgram       LoyaltyProgram?
  loyaltyPointsConfigs LoyaltyPointsConfig[]
  referralPrograms     ReferralProgram[]

  drivers    Driver[]
  vehicles   Vehicle[]
  deliveries Delivery[]

  @@index([slug])
  @@map("organization")
}

model Member {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           MemberRole
  isActive       Boolean      @default(true)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  phone          String?
  email          String?
  address        String?
  age            String?
  tags           String?

  auditLogs            AuditLog[]
  sales                Sale[]
  purchases            Purchase[]
  purchasePayments     PurchasePayment[]
  stockAdjustments     StockAdjustment[]
  stockMovements       StockMovement[]
  loyaltyTransactions  LoyaltyTransaction[]
  cashDrawers          CashDrawer[]
  inventoryManagements InventoryLocation[]  @relation("LocationManager")
  createdCustomers     Customer[]           @relation("CustomerCreatedBy")
  updatedCustomers     Customer[]           @relation("CustomerUpdatedBy")
  uploadedAttachments  Attachment[]
  processedReturns     Return[]
  expenseApprovals     ExpenseApproval[]    @relation("ApproverMember")

  notifications            Notification[]
  approvalStepConditions   ApprovalStepCondition[] @relation("LocationConditions")
  approvalStepActions      ApprovalStepAction[]    @relation("ApprovalStepActionMember")
  headedDepartments        Department[]            @relation("DepartmentHead")
  // Expense relations
  submittedExpenses        Expense[]               @relation("ExpenseSubmitter")
  approvedExpenses         Expense[]               @relation("ExpenseApprover")
  createdBudgets           Budget[]
  createdRecurringExpenses RecurringExpense[]
  generatedBudgetReports   BudgetReport[]
  cardId                   String?                 @unique
  mpesaPaymentRequests     MpesaPaymentRequest[]

  departmentMemberships DepartmentMember[]

  // --- Attendance Tracking Fields ---
  isCheckedIn              Boolean            @default(false)
  lastCheckInTime          DateTime?
  currentCheckInLocationId String? // References InventoryLocation
  currentCheckInLocation   InventoryLocation? @relation(fields: [currentCheckInLocationId], references: [id], onDelete: SetNull)
  currentAttendanceLogId   String?            @unique // Link to the active AttendanceLog record
  currentAttendanceLog     AttendanceLog?     @relation("ActiveCheckIn", fields: [currentAttendanceLogId], references: [id], onDelete: SetNull)
  attendanceLogs           AttendanceLog[]
  // --- End Attendance Tracking Fields ---

  orders Order[]

  // New field to mark temporary guest members
  isGuest        Boolean   @default(false)
  guestExpiresAt DateTime? // Expiration for the guest account

  status            Status             @default(OFFLINE)
  sentMessages      Message[]
  reactions         Reaction[]
  mentions          Mention[]
  favorites         Favorite[]
  channels          ChannelMember[]
  createdChannels   Channel[]          @relation("ChannelCreator")
  assistantMessages AssistantMessage[]

  customRoles      CustomRole[] @relation("MemberCustomRoles")
  generatedReports Report[]
  driver           Driver?

  @@unique([organizationId, userId])
  @@index([organizationId, userId])
  @@index([userId])
  @@index([cardId])
  @@index([userId, cardId])
  @@index([organizationId])
  @@index([isCheckedIn])
  @@map("member")
}

// Defines the base type of a unit.

enum UnitType {
  COUNT // For discrete items like pieces, dozens, boxes
  WEIGHT // For items measured by weight like kg, g, lb
  VOLUME // For items measured by volume like L, mL
  LENGTH // For items measured by length like m, cm
  AREA // For items measured by area like sq m, sq ft
  TIME // For service items measured by time like hour, minute
  OTHER
}

// Stores the universal, system-wide units of measure.
// This table is NOT organization-specific.

model SystemUnit {
  id     String   @id @default(cuid())
  name   String   @unique // e.g., "Kilogram", "Piece", "Liter"
  symbol String   @unique // e.g., "kg", "pc", "L"
  type   UnitType // The physical quantity the unit measures.

  // Relations for conversion
  conversionsFrom UnitConversion[] @relation("FromUnit")
  conversionsTo   UnitConversion[] @relation("ToUnit")

  // Relations to product models (replacing UnitOfMeasure)
  productVariantBaseUnits     ProductVariant[]     @relation("PVBaseUnit")
  productVariantStockingUnits ProductVariant[]     @relation("PVStockingUnit")
  variantSellingUnits         VariantSellingUnit[]
  purchaseItemOrderUnits      PurchaseItem[]       @relation("PIOrderUnit")
  saleItemSellingUnits        SaleItem[]           @relation("SISellingUnit")

  @@map("system_unit")
}

// Stores conversion factors between two system units.

model UnitConversion {
  id         String     @id @default(cuid())
  fromUnitId String
  fromUnit   SystemUnit @relation("FromUnit", fields: [fromUnitId], references: [id], onDelete: Cascade)
  toUnitId   String
  toUnit     SystemUnit @relation("ToUnit", fields: [toUnitId], references: [id], onDelete: Cascade)
  factor     Decimal    @db.Decimal(20, 10) // The multiplication factor to convert from 'fromUnit' to 'toUnit'

  @@unique([fromUnitId, toUnitId])
  @@map("unit_conversion")
}

model Invitation {
  id             String           @id @default(cuid())
  organizationId String
  organization   Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           MemberRole
  status         InvitationStatus @default(PENDING)
  token          String           @unique
  expiresAt      DateTime
  inviterId      String
  inviter        User             @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  // New fields for channel-specific guest invitations
  channelId     String? // The channel the guest is invited to
  channel       Channel? @relation(fields: [channelId], references: [id], onDelete: SetNull)
  isGuestInvite Boolean  @default(false) // Flag to identify guest invitations

  // Index the new channelId field
  @@index([email])
  @@index([organizationId])
  @@index([inviterId])
  @@index([channelId])
  @@map("invitation")
}

// --- Department Models (Department, DepartmentMember, DepartmentMemberRole - as previously defined) ---

model Department {
  id             String       @id @default(cuid())
  name           String
  image          String?
  banner         String?
  description    String?
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  headId            String? // References the Member who is the head
  head              Member?            @relation("DepartmentHead", fields: [headId], references: [id], onDelete: SetNull)
  departmentMembers DepartmentMember[]
  activeBudgetId    String?            @unique
  activeBudget      Budget?            @relation("DepartmentBudget", fields: [activeBudgetId], references: [id], onDelete: SetNull)
  budgets           Budget[]           @relation("DepartmentBudgets")

  customFields Json?

  @@unique([organizationId, name])
  @@index([organizationId])
  @@map("department")
}

model Backup {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  fileUrl  String // URL to access the backup file
  fileSize Float // Size of the backup file in bytes
  status   BackupStatus @default(COMPLETED)
  notes    String? // Optional notes, e.g., "Manual backup before migration"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@map("backups")
}

enum BackupStatus {
  PENDING
  COMPLETED
  FAILED
  RESTORING
}

model DepartmentMember {
  id                 String               @id @default(cuid())
  departmentId       String
  department         Department           @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  memberId           String
  member             Member               @relation(fields: [memberId], references: [id], onDelete: Cascade)
  role               DepartmentMemberRole @default(MEMBER) // Role within the department
  canApproveExpenses Boolean              @default(false) // Specific flag if this member can approve expenses for the dept
  canManageBudget    Boolean              @default(false) // Specific flag for budget management permissions
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  // A member can only be in a department once
  @@unique([departmentId, memberId])
  @@index([memberId])
  @@index([departmentId])
  @@map("department_member")
}

enum DepartmentMemberRole {
  HEAD // Department Head with full control over the department
  MANAGER // Managerial role within the department
  MEMBER // Regular member of the department
  VIEWER // Read-only access to department information
}

model Category {
  id            String     @id @default(cuid())
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  name          String
  description   String?
  parentId      String?
  parent        Category?  @relation("CategoryToSubcategory", fields: [parentId], references: [id], onDelete: Restrict)
  subcategories Category[] @relation("CategoryToSubcategory")
  products      Product[]
  color         String?
  code          String     @unique

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, name])
  @@index([name])
  @@index([organizationId])
  @@index([organizationId, name])
}

model Product {
  id          String   @id @default(cuid())
  name        String
  description String?
  sku         String   @unique
  barcode     String?  @unique
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id])
  isActive    Boolean  @default(true)
  imageUrls   String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Loyalty Points Override for this specific product
  pointsOnPurchase Int?

  // Physical dimensions for space calculation
  width            Float?
  height           Float?
  length           Float?
  dimensionUnit    MeasurementUnit?
  weight           Float?
  weightUnit       MeasurementUnit?
  volumetricWeight Float? // Calculated dimensional weight

  brand               String?
  rating              Float?
  lowStockThreshold   Int?
  isNew               Boolean  @default(false)
  detailedDescription String?
  tags                String[]
  isFeatured          Boolean  @default(false)

  defaultLocationId String?
  defaultLocation   InventoryLocation? @relation("ProductDefaultLocation", fields: [defaultLocationId], references: [id], onDelete: SetNull)

  // Loyalty Points Override
  loyaltyPointsOverride Int? // Specific points for this product, overrides default calculation

  // Relations
  variants     ProductVariant[]
  variantStock ProductVariantStock[]
  suppliers    ProductSupplier[]

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([name])
  @@index([sku])
  @@index([organizationId])
  @@index([organizationId, id])
  @@index([defaultLocationId])
}

model ProductVariant {
  id               String                @id @default(cuid())
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  productId        String
  product          Product               @relation(fields: [productId], references: [id], onDelete: Cascade)
  name             String
  sku              String
  barcode          String?               @unique
  attributes       Json
  isActive         Boolean               @default(true)
  reorderPoint     Int                   @default(5)
  reorderQty       Int                   @default(10)
  lowStockAlert    Boolean               @default(false)
  buyingPrice      Decimal               @db.Decimal(10, 2)
  wholesalePrice   Decimal?              @db.Decimal(10, 2)
  retailPrice      Decimal?              @db.Decimal(10, 2)
  orderItems       OrderItem[]
  isPopular        Boolean               @default(false)
  isNew            Boolean               @default(false)
  promotionalPrice Decimal?              @db.Decimal(10, 2)
  saleItems        SaleItem[]
  purchaseItems    PurchaseItem[]
  stockBatches     StockBatch[]
  stockAdjustments StockAdjustment[]
  stockMovements   StockMovement[]
  variantStocks    ProductVariantStock[]
  suppliers        ProductSupplier[]

  // Loyalty Points Override for this specific variant
  pointsOnPurchase Int?

  // Loyalty Points Override
  loyaltyPointsOverride Int? // Specific points for this variant, overrides product and default calculation

  // MODIFIED: Relations now point to the universal SystemUnit model
  baseUnitId     String
  baseUnit       SystemUnit           @relation("PVBaseUnit", fields: [baseUnitId], references: [id], onDelete: Restrict)
  stockingUnitId String
  stockingUnit   SystemUnit           @relation("PVStockingUnit", fields: [stockingUnitId], references: [id], onDelete: Restrict)
  sellingUnits   VariantSellingUnit[]

  @@unique([productId, sku])
  @@unique([productId, barcode])
  @@index([sku])
}

model VariantSellingUnit {
  id        String         @id @default(cuid())
  variantId String
  variant   ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  // MODIFIED: unitOfMeasureId now points to SystemUnit
  unitOfMeasureId String
  unitOfMeasure   SystemUnit @relation(fields: [unitOfMeasureId], references: [id], onDelete: Restrict)

  retailPrice    Decimal? @db.Decimal(10, 2)
  wholesalePrice Decimal? @db.Decimal(10, 2)

  @@unique([variantId, unitOfMeasureId])
  @@map("variant_selling_unit")
}

enum SupplierType {
  manufacturer
  distributor
  wholesaler
  service_provider
}

enum RiskLevel {
  low
  medium
  high
}

model Supplier {
  id                 String       @id @default(cuid())
  name               String
  code               String       @unique // Add this
  type               SupplierType // Add this
  website            String? // Add this
  taxId              String? // Add this
  registrationNumber String? // Add this
  currency           String? // Add this
  categories         String[] // Add this
  customBadges       String[] // Add this
  riskLevel          RiskLevel    @default(low) // Add this

  // Contact Info
  primaryContact String // Rename from contactName
  phone          String?
  email          String? @unique

  // Address Info
  street  String?
  city    String?
  state   String?
  zipCode String?
  country String?

  paymentTerms String?
  leadTime     Int?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  customFields Json?

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  products          ProductSupplier[]
  purchases         Purchase[]
  expenses          Expense[]
  recurringExpenses RecurringExpense[]
  stockBatches      StockBatch[]

  @@unique([organizationId, name])
  @@unique([organizationId, email])
  @@unique([organizationId, id])
  @@index([organizationId])
}

model ProductSupplier {
  id                   String          @id @default(cuid())
  productId            String
  product              Product         @relation(fields: [productId], references: [id], onDelete: Cascade) // Added onDelete
  variantId            String?
  variant              ProductVariant? @relation(fields: [variantId], references: [id], onDelete: Cascade) // Added onDelete
  supplierId           String
  supplier             Supplier        @relation(fields: [supplierId], references: [id], onDelete: Cascade) // Added onDelete
  supplierSku          String? // The SKU used by the supplier for this product
  costPrice            Decimal         @db.Decimal(10, 2)
  minimumOrderQuantity Int? // Added: Minimum quantity required by supplier
  packagingUnit        String? // Added: e.g., "Case of 12", "Pallet", "Each"
  isPreferred          Boolean         @default(false) // Is this the preferred supplier for this product?
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt

  @@unique([productId, supplierId])
  @@index([supplierId])
}

enum CustomerCreationType {
  MEMBER_CREATED
  ONLINE_REGISTRATION
  IMPORTED
  API
  GUEST
  OTHER
}

model Customer {
  id            String               @id @default(cuid())
  name          String
  email         String? // Unique within an organization
  phone         String?
  address       String?
  notes         String?
  company       String?
  avatar        String?
  gender        String?
  customerType  String?
  dateOfBirth   String?
  loyaltyPoints Int                  @default(0)
  isActive      Boolean              @default(true)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  createdById   String?
  updatedById   String?
  creationType  CustomerCreationType @default(MEMBER_CREATED)

  // Loyalty System Fields
  loyaltyTierId String?
  loyaltyTier   LoyaltyTier? @relation(fields: [loyaltyTierId], references: [id], onDelete: SetNull)

  // Relations
  organizationId      String
  organization        Organization         @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  sales               Sale[]
  loyaltyTransactions LoyaltyTransaction[]
  createdBy           Member?              @relation("CustomerCreatedBy", fields: [createdById], references: [id], onDelete: Restrict)
  updatedBy           Member?              @relation("CustomerUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  orders Order[]

  @@unique([organizationId, email])
  @@unique([organizationId, name])
  @@index([email, organizationId])
  @@index([name])
  @@index([email])
  @@index([organizationId])
}

model Tax {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String // e.g., "VAT", "Sales Tax"
  rate           Decimal      @db.Decimal(5, 4) // e.g., 0.16 for 16%
  description    String?
  isDefault      Boolean      @default(false)
  isActive       Boolean      @default(true)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relation to sales where this tax was applied
  appliedToSales AppliedTax[]

  @@unique([organizationId, name])
  @@index([organizationId])
  @@map("tax")
}

// --- New AppliedTax Model (Junction Table) ---

model AppliedTax {
  id        String   @id @default(cuid())
  saleId    String
  sale      Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)
  taxId     String
  tax       Tax      @relation(fields: [taxId], references: [id], onDelete: Restrict) // Prevent deleting a tax if it's been used
  taxAmount Decimal  @db.Decimal(10, 2) // The amount of tax applied for this specific tax on this sale
  createdAt DateTime @default(now())

  @@unique([saleId, taxId])
  @@index([saleId])
  @@index([taxId])
  @@map("applied_tax")
}

// --- Transactional Models ---

model Sale {
  id             String    @id @default(cuid())
  saleNumber     String
  customerId     String?
  customer       Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull) // Allow sale without customer, or if customer deleted
  memberId       String
  member         Member    @relation(fields: [memberId], references: [id])
  saleDate       DateTime  @default(now())
  totalAmount    Decimal   @db.Decimal(10, 2) // Before discounts and taxes
  discountAmount Decimal   @default(0) @db.Decimal(10, 2)
  taxAmount      Decimal   @default(0) @db.Decimal(10, 2)
  finalAmount    Decimal   @default(0) @db.Decimal(10, 2) // After discounts and taxes

  amountReceived Decimal? @db.Decimal(10, 2) // Amount tendered by the customer, especially for cash payments.
  change         Decimal? @db.Decimal(10, 2) // Change given back to the customer.

  paymentMethod PaymentMethod
  paymentStatus PaymentStatus     @default(PENDING)
  locationId    String // Location where the sale was made
  location      InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Cascade) // Prevent deletion if sales exist
  notes         String?
  cashDrawerId  String?
  cashDrawer    CashDrawer?       @relation(fields: [cashDrawerId], references: [id], onDelete: SetNull) // Allow sale if drawer deleted
  receiptUrl    String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  orders        Order[]

  // Relations
  items              SaleItem[]
  attachments        Attachment[]
  loyaltyTransaction LoyaltyTransaction?
  returns            Return[]
  appliedTaxes       AppliedTax[]

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Added onDelete

  // Enforce uniqueness per organization
  @@unique([organizationId, saleNumber])
  @@index([memberId])
  @@index([saleDate])
  @@index([customerId])
  @@index([organizationId, saleDate])
  @@index([organizationId, customerId])
  @@index([organizationId])
}

model SaleItem {
  id             String         @id @default(cuid())
  saleId         String
  sale           Sale           @relation(fields: [saleId], references: [id], onDelete: Cascade)
  variantId      String
  variant        ProductVariant @relation(fields: [variantId], references: [id], onDelete: Restrict)
  stockBatchId   String?
  stockBatch     StockBatch?    @relation(fields: [stockBatchId], references: [id], onDelete: Restrict)
  quantity       Int
  unitPrice      Decimal        @db.Decimal(10, 2)
  unitCost       Decimal        @db.Decimal(10, 2)
  discountAmount Decimal        @default(0) @db.Decimal(10, 2)
  taxRate        Decimal        @default(0) @db.Decimal(5, 4)
  taxAmount      Decimal        @db.Decimal(10, 2)
  totalAmount    Decimal        @db.Decimal(10, 2)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  returns        ReturnItem[]

  sellingUnitId String
  sellingUnit   SystemUnit @relation("SISellingUnit", fields: [sellingUnitId], references: [id], onDelete: Restrict)

  @@index([saleId])
  @@index([variantId])
  @@index([stockBatchId])
}

enum OrderStatus {
  PENDING_CONFIRMATION // Order placed, awaiting business confirmation (e.g., restaurant)
  CONFIRMED // Order confirmed by the business
  PREPARING // Order is being prepared (e.g., food, package)
  READY_FOR_PICKUP // Order is ready for customer pickup
  OUT_FOR_DELIVERY // Order is out for delivery
  DELIVERED // Order has been delivered
  COMPLETED // Order fulfilled and completed (especially for services/digital goods)
  CANCELLED // Order was cancelled
  FAILED // Order processing failed (e.g., payment issue)
  ON_HOLD // Order is temporarily on hold
}

enum OrderType {
  RETAIL_SALE // Corresponds to your current Sale model
  ONLINE_ORDER // For e-commerce type orders
  RESTAURANT_DINE_IN // For restaurant dine-in
  RESTAURANT_TAKEOUT // For restaurant takeout
  RESTAURANT_DELIVERY // For restaurant's own delivery
  SERVICE_BOOKING // For booking services
  SUBSCRIPTION // For recurring orders/subscriptions
  OTHER // For any other type of order
}

enum FulfillmentType {
  PHYSICAL_DELIVERY
  DIGITAL_DOWNLOAD
  PICKUP_IN_STORE
  DINE_IN
  SERVICE_PROVISION
}

// --- Order Models ---

model Order {
  id             String       @id @default(cuid())
  orderNumber    String // Human-readable unique order number
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  memberId   String? // Member who placed or is managing the order
  member     Member?   @relation(fields: [memberId], references: [id], onDelete: SetNull)

  status          OrderStatus     @default(PENDING_CONFIRMATION)
  orderType       OrderType       @default(ONLINE_ORDER)
  fulfillmentType FulfillmentType @default(PHYSICAL_DELIVERY)

  items OrderItem[]

  subTotal       Decimal @db.Decimal(12, 2) // Sum of (OrderItem.unitPrice * OrderItem.quantity) before discounts and taxes
  discountAmount Decimal @default(0) @db.Decimal(12, 2) // Order-level discount
  taxAmount      Decimal @default(0) @db.Decimal(12, 2) // Order-level tax
  shippingAmount Decimal @default(0) @db.Decimal(12, 2)
  totalAmount    Decimal @db.Decimal(12, 2) // Final amount to be paid

  paymentMethod        PaymentMethod? // From your existing enum [cite: 188]
  paymentStatus        PaymentStatus  @default(PENDING) // From your existing enum [cite: 188]
  paymentTransactionId String? // Reference to a payment gateway transaction

  // --- Timestamps ---
  placedAt     DateTime  @default(now()) // When the customer placed the order
  confirmedAt  DateTime? // When the business confirmed the order
  preparingAt  DateTime?
  readyAt      DateTime? // Ready for pickup/delivery
  dispatchedAt DateTime?
  deliveredAt  DateTime?
  completedAt  DateTime? // When the order is fully resolved
  cancelledAt  DateTime?
  updatedAt    DateTime  @updatedAt

  // --- Fulfillment Details ---
  shippingAddress  Json? // Could be JSON for structured address
  billingAddress   Json? // Could be JSON
  deliveryNotes    String?
  pickupLocationId String? // If pickup, link to InventoryLocation [cite: 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105]
  pickupLocation   InventoryLocation? @relation("OrderPickupLocation", fields: [pickupLocationId], references: [id], onDelete: SetNull)

  // --- Restaurant Specific ---
  tableNumber              String? // For dine-in
  estimatedPreparationTime Int? // In minutes

  // --- General ---
  notes String? // Customer or internal notes
  tags  String[] // For categorization/filtering

  // --- Delivery Information ---
  delivery Delivery?

  // --- Potential Link to Sale (if you want to keep Sale for point-of-sale and Order for other channels) ---
  saleId String? @unique // If this order resulted in a direct Sale record
  sale   Sale?   @relation(fields: [saleId], references: [id])

  @@unique([organizationId, orderNumber])
  @@index([organizationId, customerId])
  @@index([organizationId, status])
  @@index([organizationId, orderType])
  @@index([placedAt])
  @@map("order")
}

model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  variantId   String
  variant     ProductVariant @relation(fields: [variantId], references: [id], onDelete: Restrict) // ProductVariant from your schema [cite: 46, 47, 48]
  productName String // Snapshot of product name at time of order
  variantName String // Snapshot of variant name

  quantity   Int
  unitPrice  Decimal @db.Decimal(10, 2) // Price per unit at time of order (can include item-specific discounts)
  totalPrice Decimal @db.Decimal(12, 2) // quantity * unitPrice

  // --- Optional fields ---
  discountAmount Decimal  @default(0) @db.Decimal(10, 2) // Item-specific discount amount
  taxRate        Decimal? @db.Decimal(5, 4) // Item-specific tax rate
  taxAmount      Decimal? @db.Decimal(10, 2) // Item-specific tax amount

  notes String? // E.g., customization for a food item

  // --- Fulfillment related for this item ---
  // stockBatchId   String?  // If tracking specific batches for this order item [cite: 73, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140]
  // stockBatch     StockBatch? @relation(fields: [stockBatchId], references: [id], onDelete:SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([variantId])
  @@map("order_item")
}

enum AssistantType {
  RULE_BASED // Executes predefined rules and actions
  AI_LLM // Uses Language Models (more complex, future scope)
}

enum AssistantTaskType {
  GENERATE_SALES_REPORT
  GENERATE_INVENTORY_REPORT
  MONITOR_LOW_STOCK
  CREATE_PURCHASE_ORDER
  SEND_ORDER_STATUS_NOTIFICATION
  PROCESS_RECURRING_EXPENSE
  CHECK_ATTENDANCE_ANOMALIES
}

enum AssistantTriggerType {
  SCHEDULE // Runs at a specific time/interval (e.g., cron job)
  EVENT // Runs when a specific event occurs (e.g., Sale created, Stock level changed)
  MANUAL // Runs only when manually triggered
}

enum AssistantLogStatus {
  PENDING // Task is scheduled or triggered but not yet running
  RUNNING // Task is currently being executed
  SUCCESS // Task completed successfully
  FAILED // Task execution failed
  WARNING // Task completed but with warnings or partial success
}

model Assistant {
  id             String        @id @default(cuid())
  organizationId String
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String // e.g., "Inventory Bot", "Reporting Assistant"
  description    String?
  type           AssistantType @default(RULE_BASED)
  isActive       Boolean       @default(true)
  configuration  Json? // Specific settings, API keys, etc.
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  tasks AssistantTask[]
  logs  AssistantLog[]

  channel           Channel? // NEW: Link to the dedicated channel for this assistant
  assistantMessages AssistantMessage[] // NEW: Messages involving this assistant

  @@unique([organizationId, name])
  @@index([organizationId])
  @@map("assistant")
}

model AssistantMessage {
  id        String   @id @default(cuid())
  content   String
  isUser    Boolean // True if the message is from the user, false if from the assistant
  createdAt DateTime @default(now())

  channelId String
  channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  memberId String // User who sent/received the message
  user     Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  assistantId String
  assistant   Assistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)

  // Optional: Store metadata like tokens used, latency, model version etc.
  metadata Json?

  @@index([channelId])
  @@index([memberId])
  @@index([assistantId])
  @@map("assistant_message")
}

model AssistantTask {
  id                   String               @id @default(cuid())
  assistantId          String
  assistant            Assistant            @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  name                 String // e.g., "Daily Sales Report", "Low Stock PO Generator"
  description          String?
  taskType             AssistantTaskType
  triggerType          AssistantTriggerType
  triggerConfiguration Json? // e.g., {"cron": "0 1 * * *"}, {"event": "LOW_STOCK", "threshold": 10}
  actionConfiguration  Json? // e.g., {"report_type": "SALES", "recipient": "manager@org.com"}
  isActive             Boolean              @default(true)
  lastRunAt            DateTime?
  nextRunAt            DateTime? // For scheduled tasks
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  logs AssistantLog[]

  @@index([assistantId])
  @@index([isActive, nextRunAt])
  @@map("assistant_task")
}

model AssistantLog {
  id              String             @id @default(cuid())
  assistantId     String
  assistant       Assistant          @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  assistantTaskId String
  task            AssistantTask      @relation(fields: [assistantTaskId], references: [id], onDelete: Cascade)
  organizationId  String
  organization    Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  startedAt       DateTime           @default(now())
  finishedAt      DateTime?
  status          AssistantLogStatus @default(PENDING)
  details         String? // Human-readable log (e.g., "Checked 50 variants, found 3 low.")
  output          Json? // e.g., {"reportUrl": "...", "purchaseOrderId": "..."}
  errorMessage    String?

  @@index([assistantTaskId])
  @@index([organizationId, status])
  @@index([startedAt])
  @@map("assistant_log")
}

model Purchase {
  id             String         @id @default(cuid())
  purchaseNumber String // Unique within an organization
  supplierId     String
  supplier       Supplier       @relation(fields: [supplierId], references: [id], onDelete: Restrict) // Prevent supplier deletion if purchases exist
  memberId       String // Changed from userId
  member         Member         @relation(fields: [memberId], references: [id]) // Changed relation name
  orderDate      DateTime       @default(now())
  expectedDate   DateTime?
  receivedDate   DateTime? // Date when the entire order was fully received
  totalAmount    Decimal        @db.Decimal(10, 2) // Should be calculated from items' totalCost
  paidAmount     Decimal        @default(0) @db.Decimal(10, 2)
  status         PurchaseStatus @default(ORDERED)
  notes          String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  expenses       Expense[]

  // Relations
  items       PurchaseItem[]
  payments    PurchasePayment[]
  attachments Attachment[]

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Added onDelete

  // Enforce uniqueness per organization
  @@unique([organizationId, purchaseNumber])
  @@index([orderDate])
  @@index([supplierId])
  @@index([status])
  @@index([organizationId])
}

model PurchaseItem {
  id               String         @id @default(cuid())
  purchaseId       String
  purchase         Purchase       @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  variantId        String
  variant          ProductVariant @relation(fields: [variantId], references: [id], onDelete: Restrict)
  orderedQuantity  Int
  receivedQuantity Int            @default(0)
  unitCost         Decimal        @db.Decimal(10, 2)
  totalCost        Decimal        @db.Decimal(10, 2)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  stockBatches     StockBatch[]

  // MODIFIED: orderedUnitId now points to SystemUnit
  orderedUnitId String
  orderedUnit   SystemUnit @relation("PIOrderUnit", fields: [orderedUnitId], references: [id], onDelete: Restrict)

  @@index([purchaseId])
  @@index([variantId])
}

model PurchasePayment {
  id            String        @id @default(cuid())
  purchaseId    String
  purchase      Purchase      @relation(fields: [purchaseId], references: [id], onDelete: Cascade) // Cascade delete with purchase
  memberId      String // Changed from userId
  member        Member        @relation(fields: [memberId], references: [id]) // Changed relation name
  paymentDate   DateTime      @default(now())
  amount        Decimal       @db.Decimal(10, 2)
  paymentMethod PaymentMethod
  reference     String? // e.g., Cheque number, transaction ID
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([purchaseId])
  @@index([paymentDate])
  @@index([memberId])
}

model Return {
  id           String       @id @default(cuid())
  returnNumber String // Unique within an organization
  saleId       String // The original sale ID
  sale         Sale         @relation(fields: [saleId], references: [id], onDelete: Restrict) // Prevent sale deletion if returns exist
  reason       ReturnReason // Overall reason for the return
  status       ReturnStatus @default(PENDING)
  notes        String?
  processedAt  DateTime? // When the return was finalized (approved/rejected)
  memberId     String // Who processed the return
  member       Member       @relation(fields: [memberId], references: [id]) // Added relation to Member
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  // Relations
  items ReturnItem[] // List of items being returned

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Added onDelete

  // Enforce uniqueness per organization
  @@unique([organizationId, returnNumber])
  @@index([saleId])
  @@index([status])
  @@index([createdAt])
  @@index([organizationId])
}

model ReturnItem {
  id         String           @id @default(cuid())
  returnId   String
  return     Return           @relation(fields: [returnId], references: [id], onDelete: Cascade)
  saleItemId String // Link to the specific item line from the original sale
  saleItem   SaleItem         @relation(fields: [saleItemId], references: [id], onDelete: Restrict) // Prevent sale item deletion
  quantity   Int // Quantity of this specific item being returned
  reason     ReturnReason? // Optional: Item-specific reason, overrides main Return reason if set
  status     ReturnItemStatus @default(PENDING) // Status for this specific item line
  unitPrice  Decimal          @db.Decimal(10, 2) // Price at which it was sold (copied from SaleItem for history)
  notes      String? // Item-specific notes

  // and potentially creating a new 'returned' batch or adjusting via StockAdjustment
  @@index([returnId])
  @@index([saleItemId])
}

enum ReturnStatus {
  PENDING // Return initiated, awaiting approval
  APPROVED // Return request approved, items can be returned/refunded
  REJECTED // Return request denied
  PROCESSING // Items received, processing refund/replacement
  COMPLETED // Refund/replacement issued, process finished
}

enum ReturnItemStatus {
  PENDING // Waiting for item to be returned/inspected
  RECEIVED // Item received by the store
  ACCEPTED // Item accepted for refund/replacement
  REJECTED // Item rejected (e.g., damaged by customer)
  RESTOCKED // Item put back into stock (if applicable)
  REFUNDED // Refund processed for this item
  REPLACED // Replacement issued for this item
}

enum ReturnReason {
  DEFECTIVE
  WRONG_ITEM
  NOT_AS_DESCRIBED
  CHANGE_OF_MIND
  SIZE_COLOR_ISSUE
  ARRIVED_LATE
  DUPLICATE_ORDER
  DAMAGED_IN_TRANSIT
  OTHER
}

// --- Inventory & Stock Models ---

model InventoryLocation {
  id                  String                  @id @default(cuid())
  name                String
  code                String?                 @unique
  description         String?
  isActive            Boolean                 @default(true)
  isDefault           Boolean                 @default(false)
  locationType        LocationType            @default(RETAIL_SHOP)
  address             Json?
  contact             Json?
  capacity            Json?
  settings            Json?
  parentLocationId    String?
  parentLocation      InventoryLocation?      @relation("LocationHierarchy", fields: [parentLocationId], references: [id], onDelete: SetNull)
  childLocations      InventoryLocation[]     @relation("LocationHierarchy")
  customFields        Json?
  approvalConditions  ApprovalStepCondition[] @relation("LocationCondition")
  inventoryConditions ApprovalStepCondition[] @relation("InventoryLocationConditions")
  createdAt           DateTime                @default(now())
  updatedAt           DateTime                @updatedAt
  managerId           String?
  manager             Member?                 @relation("LocationManager", fields: [managerId], references: [id], onDelete: SetNull)
  sales               Sale[]

  organizationId    String
  organization      Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  stockBatches      StockBatch[]
  stockAdjustments  StockAdjustment[]
  variantStocks     ProductVariantStock[]
  outgoingMovements StockMovement[]       @relation("FromLocationMovements")
  incomingMovements StockMovement[]       @relation("ToLocationMovements")

  zones                  StorageZone[]
  storageUnits           StorageUnit[]
  checkedInMembers       Member[]
  checkInAttendanceLogs  AttendanceLog[] @relation("CheckInLocationLogs")
  checkOutAttendanceLogs AttendanceLog[] @relation("CheckOutLocationLogs")

  defaultProducts Product[] @relation("ProductDefaultLocation")
  expenses        Expense[]
  budgets         Budget[]
  pickupOrders    Order[]   @relation("OrderPickupLocation")

  @@unique([organizationId, name])
  @@index([name])
  @@index([organizationId])
  @@index([managerId])
  @@index([locationType])
  @@index([isDefault])
  @@index([parentLocationId])
}

model StorageZone {
  id           String            @id @default(cuid())
  name         String // e.g., "Zone A", "Electronics Section"
  description  String?
  locationId   String
  location     InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Cascade)
  capacity     Float?
  capacityUnit MeasurementUnit?
  capacityUsed Float?            @default(0)
  isActive     Boolean           @default(true)
  customFields Json?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  // Relations
  storageUnits   StorageUnit[]
  organizationId String
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([locationId, name])
  @@index([locationId])
  @@index([organizationId])
}

model StorageUnit {
  id            String            @id @default(cuid())
  name          String // e.g., "Rack A1", "Bin B23"
  reference     String? // External reference number/barcode
  unitType      StorageUnitType
  locationId    String
  location      InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Cascade)
  zoneId        String?
  zone          StorageZone?      @relation(fields: [zoneId], references: [id], onDelete: SetNull)
  width         Float? // Physical dimensions
  height        Float?
  depth         Float?
  dimensionUnit String? // e.g., "cm", "inches"
  maxWeight     Float? // Maximum weight capacity
  weightUnit    String? // e.g., "kg", "lbs"
  capacity      Float? // Storage capacity
  capacityUnit  MeasurementUnit?
  capacityUsed  Float?            @default(0)
  isActive      Boolean           @default(true)
  position      String? // Physical position reference (e.g., "Aisle 5, Section B")
  customFields  Json?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Relations
  positions      StoragePosition[]
  stockBatches   StockBatch[]      @relation("UnitStockBatches") // Direct assignment to unit
  organizationId String
  organization   Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([locationId, zoneId, name])
  @@index([locationId])
  @@index([zoneId])
  @@index([unitType])
  @@index([organizationId])
}

model StoragePosition {
  id            String      @id @default(cuid())
  identifier    String // e.g., "A1-B2-C3" (unit-shelf-position)
  storageUnitId String
  storageUnit   StorageUnit @relation(fields: [storageUnitId], references: [id], onDelete: Cascade)
  width         Float? // Physical dimensions
  height        Float?
  depth         Float?
  dimensionUnit String? // e.g., "cm", "inches"
  maxWeight     Float? // Maximum weight capacity
  weightUnit    String? // e.g., "kg", "lbs"
  isOccupied    Boolean     @default(false)
  customFields  Json?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  stockBatches   StockBatch[] @relation("PositionStockBatches")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([storageUnitId, identifier])
  @@index([storageUnitId])
  @@index([isOccupied])
  @@index([organizationId])
}

model StockBatch {
  id             String            @id @default(cuid())
  variantId      String
  variant        ProductVariant    @relation(fields: [variantId], references: [id], onDelete: Cascade)
  batchNumber    String? // Manufacturer or internal batch number
  purchaseItemId String? // Link to the purchase item that created this batch
  purchaseItem   PurchaseItem?     @relation(fields: [purchaseItemId], references: [id], onDelete: SetNull)
  locationId     String // Location where this batch is physically stored
  location       InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Restrict)

  // Storage placement fields
  storageUnitId String? // Which specific storage unit contains this batch
  storageUnit   StorageUnit?     @relation("UnitStockBatches", fields: [storageUnitId], references: [id], onDelete: SetNull)
  positionId    String? // Which specific position within the unit
  position      StoragePosition? @relation("PositionStockBatches", fields: [positionId], references: [id], onDelete: SetNull)

  initialQuantity Int // Quantity when the batch was created/received
  currentQuantity Int // Current available quantity in this batch
  purchasePrice   Decimal   @db.Decimal(10, 2) // Cost per unit for items in this batch
  expiryDate      DateTime? // Expiry date for FEFO tracking
  receivedDate    DateTime  @default(now()) // Date batch was added to inventory
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  spaceOccupied Float?
  spaceUnit     MeasurementUnit?

  // Relations
  organizationId String
  organization   Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  saleItems      SaleItem[] // Track which sales depleted this batch
  adjustments    StockAdjustment[] // Adjustments specifically affecting this batch
  movements      StockMovement[] // Track movements involving this batch

  supplierId String?
  supplier   Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)

  landedCost     Decimal? @db.Decimal(10, 2) // Total cost including shipping, duties, etc.
  batchSalePrice Decimal? @db.Decimal(10, 2) // Optional batch-specific sale price

  @@index([expiryDate])
  @@index([receivedDate])
  @@index([currentQuantity])
  @@index([locationId])
  @@index([organizationId])
  @@index([storageUnitId])
  @@index([positionId])
}

model ProductVariantStock {
  id             String            @id @default(cuid())
  productId      String
  product        Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  variantId      String
  variant        ProductVariant    @relation(fields: [variantId], references: [id], onDelete: Cascade)
  locationId     String
  location       InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Cascade)
  currentStock   Int               @default(0) // Total available stock
  reservedStock  Int               @default(0) // Stock reserved but not yet deducted
  availableStock Int               @default(0) // Calculated: currentStock - reservedStock
  reorderPoint   Int               @default(5) // Location-specific reorder point
  reorderQty     Int               @default(10) // Location-specific reorder quantity
  lastUpdated    DateTime          @updatedAt

  // Relations
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Only one stock record per variant per location
  @@unique([variantId, locationId])
  @@index([productId])
  @@index([locationId])
  @@index([organizationId])
}

model StockAdjustment {
  id              String                @id @default(cuid())
  variantId       String
  variant         ProductVariant        @relation(fields: [variantId], references: [id], onDelete: Restrict)
  stockBatchId    String?
  stockBatch      StockBatch?           @relation(fields: [stockBatchId], references: [id], onDelete: SetNull)
  locationId      String
  location        InventoryLocation     @relation(fields: [locationId], references: [id], onDelete: Restrict)
  memberId        String
  member          Member                @relation(fields: [memberId], references: [id])
  quantity        Int // Positive for increase, negative for decrease
  reason          StockAdjustmentReason
  notes           String?
  adjustmentDate  DateTime              @default(now())
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  referenceNumber String? // Optional reference number for tracking

  // Relations
  movement       StockMovement? // Link to corresponding movement record
  organizationId String
  organization   Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([stockBatchId])
  @@index([adjustmentDate])
  @@index([locationId])
  @@index([memberId])
  @@index([organizationId])
}

enum StockAdjustmentReason {
  INITIAL_STOCK // Setting up initial inventory count
  RECEIVED_PURCHASE // Use StockBatch creation directly typically
  DAMAGED // Item damaged while in stock
  EXPIRED // Item expired while in stock
  LOST // Item lost or unaccounted for
  STOLEN // Item confirmed stolen
  FOUND // Item previously lost/unaccounted for is found
  RETURN_TO_SUPPLIER // Sending stock back to the supplier
  CUSTOMER_RETURN // Receiving stock back from a customer (may create a new batch or adjust existing)
  INVENTORY_COUNT // Adjustment due to physical stock count discrepancy
  TRANSFER_OUT // Stock moved to another location (use StockMovement)
  TRANSFER_IN // Stock received from another location (use StockMovement)
  OTHER // Miscellaneous adjustments
}

model StockMovement {
  id             String             @id @default(cuid())
  variantId      String
  variant        ProductVariant     @relation(fields: [variantId], references: [id], onDelete: Cascade)
  stockBatchId   String?
  stockBatch     StockBatch?        @relation(fields: [stockBatchId], references: [id], onDelete: SetNull)
  quantity       Int // Always positive: the quantity that moved
  fromLocationId String? // Source Location (null if coming from outside)
  fromLocation   InventoryLocation? @relation("FromLocationMovements", fields: [fromLocationId], references: [id], onDelete: SetNull)
  toLocationId   String? // Destination Location (null if leaving tracked inventory)
  toLocation     InventoryLocation? @relation("ToLocationMovements", fields: [toLocationId], references: [id], onDelete: SetNull)
  movementType   MovementType
  referenceId    String? // ID of related record (Sale ID, Purchase ID, etc.)
  referenceType  String? // Type of reference (e.g., "Sale", "Purchase", "Adjustment")
  adjustmentId   String?            @unique // Link to adjustment if this was an adjustment
  adjustment     StockAdjustment?   @relation(fields: [adjustmentId], references: [id], onDelete: SetNull)
  memberId       String
  member         Member             @relation(fields: [memberId], references: [id])
  notes          String?
  movementDate   DateTime           @default(now())
  createdAt      DateTime           @default(now())

  // Relations
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([stockBatchId])
  @@index([fromLocationId])
  @@index([toLocationId])
  @@index([movementType, referenceId])
  @@index([movementDate])
  @@index([memberId])
  @@index([organizationId])
}

enum MovementType {
  PURCHASE_RECEIPT // Stock entering from a supplier purchase
  SALE // Stock leaving due to a customer sale
  ADJUSTMENT_IN // Stock increased via adjustment (found, count up)
  ADJUSTMENT_OUT // Stock decreased via adjustment (damaged, lost, expired, count down)
  TRANSFER // Stock moved between internal locations
  CUSTOMER_RETURN // Stock returning from a customer
  SUPPLIER_RETURN // Stock being sent back to a supplier
  INITIAL_STOCK // Initial stock count entry
  PRODUCTION_IN // Stock created from internal production (if applicable)
  PRODUCTION_OUT // Components used in internal production (if applicable)
}

// --- Utility & Other Models ---

model Attachment {
  id          String   @id @default(cuid())
  fileName    String
  fileUrl     String // URL to access the file (e.g., S3 URL)
  mimeType    String? // Changed from fileType (e.g., "image/jpeg", "application/pdf")
  sizeBytes   Int? // Changed from fileSize
  description String?
  uploadedAt  DateTime @default(now())
  memberId    String // Who uploaded it
  member      Member   @relation(fields: [memberId], references: [id]) // Added relation to Member

  // Polymorphic-like association (can belong to Sale OR Purchase, etc.)
  relatedTo String // Model name (e.g., "Sale", "Purchase")
  relatedId String // ID of the related record

  // Relations (Original relations kept for potential direct linking, but polymorphic is more flexible)
  saleId     String?
  sale       Sale?     @relation(fields: [saleId], references: [id], onDelete: SetNull)
  purchaseId String?
  purchase   Purchase? @relation(fields: [purchaseId], references: [id], onDelete: SetNull)

  // Added Organization relation
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Add polymorphic relations for expense management
  expenseId          String?
  expense            Expense?          @relation(fields: [expenseId], references: [id], onDelete: SetNull)
  budgetId           String?
  recurringExpenseId String?
  recurringExpense   RecurringExpense? @relation(fields: [recurringExpenseId], references: [id], onDelete: SetNull)

  @@index([relatedTo, relatedId])
  @@index([saleId])
  @@index([purchaseId])
  @@index([memberId])
  @@index([organizationId])
}

model CashDrawer {
  id             String       @id @default(cuid())
  name           String // Name for the drawer (e.g., "Till 1", "Main Register")
  // locationId     String?      // Optional: Link to the physical location/terminal
  // location       InventoryLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull) // Added location relation
  memberId       String
  member         Member       @relation(fields: [memberId], references: [id])
  openingAmount  Decimal      @db.Decimal(10, 2)
  closingAmount  Decimal?     @db.Decimal(10, 2)
  expectedAmount Decimal?     @db.Decimal(10, 2) // Calculated based on sales and opening amount
  discrepancy    Decimal?     @db.Decimal(10, 2) // closingAmount - expectedAmount
  notes          String?
  openedAt       DateTime     @default(now())
  closedAt       DateTime?
  status         DrawerStatus @default(OPEN)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  sales Sale[] // Sales processed during this drawer session

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Added onDelete

  // Drawer names unique per org
  // Changed from userId
  // @@index([locationId])
  @@unique([organizationId, name])
  @@index([openedAt])
  @@index([closedAt])
  @@index([memberId])
  @@index([organizationId])
}

enum DrawerStatus {
  OPEN // Drawer session is active
  CLOSED // Drawer session ended, counts entered
  BALANCED // Closed and closing amount matches expected amount
  DISCREPANCY // Closed and closing amount does not match expected
}

// --- Audit Log Model --- (Generally good as is)

enum AuditLogAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  INVITE
  ACCESS_DENIED
}

enum AuditEntityType {
  USER
  MEMBER
  ORGANIZATION
  PRODUCT
  CATEGORY
  SUPPLIER
  CUSTOMER
  SALE
  PURCHASE
  RETURN
  STOCK_BATCH
  STOCK_ADJUSTMENT
  STOCK_MOVEMENT
  INVENTORY_LOCATION
  CASH_DRAWER
  LOYALTY
  SETTINGS
  OTHER
  EXPENSE
  BUDGET
  PROJECT
  RECURRING_EXPENSE
  ATTENDANCE
  AUTH_CHECK
}

model AuditLog {
  id             String          @id @default(cuid())
  organizationId String? // Changed from tenantId
  organization   Organization?   @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Added relation
  memberId       String? // Changed from userId (who performed the action)
  member         Member?         @relation(fields: [memberId], references: [id], onDelete: SetNull) // Keep log if member deleted
  action         AuditLogAction
  entityType     AuditEntityType // Changed from type
  entityId       String? // ID of the entity that was affected
  description    String // Human-readable description of the action
  details        Json? // Changed from metadata (e.g., old/new values for UPDATE)
  ipAddress      String?
  userAgent      String?
  performedAt    DateTime        @default(now())
  expenseId      String?
  expense        Expense?        @relation(fields: [expenseId], references: [id], onDelete: SetNull)
  budgetId       String?
  budget         Budget?         @relation(fields: [budgetId], references: [id], onDelete: SetNull)

  recurringExpenseId String?
  recurringExpense   RecurringExpense? @relation(fields: [recurringExpenseId], references: [id], onDelete: SetNull)
  expenseApprovalId  String?

  @@index([organizationId])
  @@index([memberId])
  @@index([entityType, entityId])
  @@index([performedAt])
  @@map("audit_log")
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  MOBILE_PAYMENT // e.g., Apple Pay, Google Pay, M-Pesa
  BANK_TRANSFER
  CHEQUE
  STORE_CREDIT
  GIFT_CARD
  LOYALTY_POINTS
  ON_ACCOUNT // Customer pays later
  OTHER
}

enum PaymentStatus {
  PENDING // Awaiting payment
  COMPLETED // Fully paid
  FAILED // Payment attempt failed
  REFUNDED // Payment fully refunded
  PARTIALLY_REFUNDED // Payment partially refunded
  PARTIALLY_PAID // Payment partially refunded
  CANCELLED // Payment was cancelled
  VOIDED // Payment transaction was voided before settlement
}

enum PurchaseStatus {
  DRAFT // Purchase order created but not yet sent
  ORDERED // PO sent to supplier, awaiting items
  PARTIALLY_RECEIVED // Some items received, but not all
  RECEIVED // All items received
  BILLED // Supplier invoice received (may happen before/after receiving)
  PARTIALLY_PAID // Partial payment made towards the invoice
  PAID // Invoice fully paid
  COMPLETED // Order fully received and paid/closed
  CANCELLED // Order cancelled before completion
}

// Added: Specific settings for an organization

model OrganizationSettings {
  id                String          @id @default(cuid())
  organizationId    String          @unique // Enforces one-to-one
  organization      Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  defaultCurrency   String          @default("USD") // e.g., "USD", "EUR", "GBP"
  defaultTimezone   String          @default("UTC") // e.g., "Africa/Nairobi"
  defaultTaxRate    Decimal?        @db.Decimal(5, 4) // Default tax rate for new products/sales
  inventoryPolicy   InventoryPolicy @default(FEFO) // Added: FIFO, LIFO, or FEFO preference
  lowStockThreshold Int             @default(10) // Default threshold for low stock alerts
  negativeStock     Boolean         @default(false) // Allow selling into negative stock?
  updatedAt         DateTime        @default(now()) @updatedAt

  enableCapacityTracking    Boolean          @default(false) // Enable space management features
  enforceSpatialConstraints Boolean          @default(false) // Prevent over-capacity situations
  enableProductDimensions   Boolean          @default(false) // Track product dimensions
  defaultMeasurementUnit    MeasurementUnit? // Default measurement unit for the org
  defaultDimensionUnit      String? // e.g., "cm", "inches"
  defaultWeightUnit         String? // e.g., "kg", "lbs"
  defaultTaxId              String?

  // --- Attendance Auto-Checkout Settings ---
  enableAutoCheckout Boolean @default(false)
  autoCheckoutTime   String? // Store as "HH:mm" in organization's local timezone (e.g., "17:00")

  // --- End Attendance Auto-Checkout Settings ---
  @@map("organization_settings")
}

enum MeasurementUnit {
  CUBIC_METER // m³ - Volume
  CUBIC_FEET // ft³ - Volume
  SQUARE_METER // m² - Area
  SQUARE_FEET // ft² - Area
  METER // m - Length (for shelving)
  FEET // ft - Length (for shelving)
  COUNT // Number of positions/slots
  WEIGHT_KG // Weight capacity in kg
  WEIGHT_LB // Weight capacity in lbs
}

enum StorageUnitType {
  SHELF // Standard shelf
  RACK // Pallet or other racking system
  BIN // Smaller container within a shelf/rack
  DRAWER // Pull-out storage
  PALLET // Standalone pallet
  SECTION // Demarcated area within a zone
  REFRIGERATOR // Temperature controlled unit
  FREEZER // Freezer unit
  CABINET // Enclosed cabinet
  BULK_AREA // Open area for bulk storage
  OTHER // Other storage type
}

enum LocationType {
  RETAIL_SHOP // A store front location where sales occur directly
  WAREHOUSE // A storage facility primarily for inventory
  DISTRIBUTION // Facility for receiving and distributing stock
  PRODUCTION // Manufacturing facility
  SUPPLIER // External supplier location (for reference)
  CUSTOMER // External customer location (for reference)
  TEMPORARY // Temporary or pop-up location
  OTHER // Any other location type
}

// Added: Enum for inventory policy setting

enum InventoryPolicy {
  FIFO // First-In, First-Out (Based on receivedDate)
  LIFO // Last-In, First-Out (Based on receivedDate)
  FEFO // First-Expired, First-Out (Based on expiryDate, fallback to FIFO if no expiry)
}

model Expense {
  id                 String             @id @default(cuid())
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  expenseNumber      String
  description        String
  amount             Decimal            @db.Decimal(10, 2)
  expenseDate        DateTime           @default(now())
  categoryId         String
  category           ExpenseCategory    @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  paymentMethod      PaymentMethod
  receiptUrl         String?
  notes              String?
  isReimbursable     Boolean            @default(false)
  status             ExpenseStatus      @default(PENDING)
  approvalDate       DateTime?
  locationId         String?
  location           InventoryLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull)
  memberId           String
  member             Member             @relation("ExpenseSubmitter", fields: [memberId], references: [id], onDelete: Restrict)
  approverId         String?
  approver           Member?            @relation("ExpenseApprover", fields: [approverId], references: [id], onDelete: SetNull)
  supplierId         String?
  supplier           Supplier?          @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  organizationId     String
  organization       Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  attachments        Attachment[]
  auditLogs          AuditLog[]
  purchaseId         String?
  purchase           Purchase?          @relation(fields: [purchaseId], references: [id], onDelete: SetNull)
  budgetId           String?
  budget             Budget?            @relation(fields: [budgetId], references: [id], onDelete: SetNull)
  approval           ExpenseApproval?   @relation("ExpenseApproval")
  recurringExpenseId String?
  recurringExpense   RecurringExpense?  @relation("RecurringExpenseExpenses", fields: [recurringExpenseId], references: [id], onDelete: SetNull)
  tags               String[]
  taxAmount          Decimal?           @db.Decimal(10, 2)
  mileage            Float?
  isBillable         Boolean            @default(false)

  @@unique([organizationId, expenseNumber])
  @@index([isBillable])
  @@index([expenseDate])
  @@index([memberId])
  @@index([locationId])
  @@index([organizationId])
  @@index([status])
}

model ExpenseCategory {
  id                 String                  @id @default(cuid())
  name               String
  description        String?
  code               String? // Short code for reporting
  color              String? // Hex color code for UI representation
  isActive           Boolean                 @default(true)
  requiresApproval   Boolean                 @default(false) // Whether expenses in this category require approval
  defaultBudget      Float? // Default budget amount for this category
  organizationId     String
  organization       Organization            @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  expenses           Expense[]
  recurringExpenses  RecurringExpense[]
  approvalConditions ApprovalStepCondition[]

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([isActive])
}

enum ExpenseStatus {
  PENDING
  APPROVED
  REJECTED
  PAID
  REIMBURSED
}

model RecurringExpense {
  id            String              @id @default(cuid())
  description   String
  amount        Decimal             @db.Decimal(10, 2)
  categoryId    String
  category      ExpenseCategory     @relation(fields: [categoryId], references: [id])
  paymentMethod PaymentMethod
  frequency     RecurrenceFrequency
  startDate     DateTime
  endDate       DateTime?
  isActive      Boolean             @default(true)
  nextDueDate   DateTime // Calculated field

  // Supplier if applicable
  supplierId String?
  supplier   Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)

  // Relations
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdById    String
  createdBy      Member       @relation(fields: [createdById], references: [id], onDelete: Restrict)

  expenses     Expense[]      @relation("RecurringExpenseExpenses")
  auditLogs    AuditLog[]
  executionLog ExecutionLog[]
  attachments  Attachment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([nextDueDate])
  @@index([isActive])
}

enum RecurrenceFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

model ExpenseApproval {
  id           String         @id @default(cuid())
  expenseId    String         @unique
  expense      Expense        @relation("ExpenseApproval", fields: [expenseId], references: [id], onDelete: Cascade) // Cascade delete approval if expense is deleted
  approverId   String
  approver     Member         @relation("ApproverMember", fields: [approverId], references: [id], onDelete: Restrict) // Prevent approver deletion if they have pending approvals
  status       ApprovalStatus @default(PENDING)
  // Comments provided by the approver during decision.
  comments     String?
  decisionDate DateTime

  // Standard fields
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([approverId])
  @@index([status])
  @@index([organizationId])
}

model ApprovalWorkflow {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation("OrgWorkflows", fields: [organizationId], references: [id], onDelete: Cascade)
  name           String // e.g., "Standard Expense Approval", "High Value Purchase Approval"
  description    String?
  isActive       Boolean      @default(true) // Whether this workflow can be selected as the active one
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  steps ApprovalWorkflowStep[] // Ordered steps in the workflow

  // Relation for tracking which orgs have this as active (optional, but useful)
  activeForOrganizations       Organization[] @relation("ActiveOrgWorkflow")
  expenseApprovalOrganizations Organization[] @relation("ExpenseApprovalWorkflows")

  // departmentId String?
  // department   Department? @relation("DepartmentWorkflows", fields: [departmentId], references: [id], onDelete:SetNull)
  // defaultForDepartment Department? @relation("DefaultDepartmentWorkflow") // If this workflow is a default for a department
  @@unique([organizationId, name])
  @@index([organizationId, isActive])
}

model ApprovalWorkflowStep {
  id                     String           @id @default(cuid())
  approvalWorkflowId     String
  workflow               ApprovalWorkflow @relation(fields: [approvalWorkflowId], references: [id], onDelete: Cascade)
  stepNumber             Int // Order of the step (e.g., 1, 2, 3) - lower numbers first
  name                   String // e.g., "Manager Approval", "Finance Review", "Director Sign-off"
  description            String?
  allConditionsMustMatch Boolean          @default(true) // If true, ALL conditions must match expense; if false, ANY condition match triggers step

  conditions ApprovalStepCondition[] // Conditions that trigger this step
  actions    ApprovalStepAction[] // Actions required for this step (who approves) min

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([approvalWorkflowId, stepNumber])
}

model ApprovalStepCondition {
  id     String               @id @default(cuid())
  stepId String
  step   ApprovalWorkflowStep @relation(fields: [stepId], references: [id], onDelete: Cascade)
  type   ConditionType // Type of condition (Amount, Category, Location, etc.)

  // --- Condition Values (only relevant fields used based on 'type') ---
  minAmount         Decimal?           @db.Decimal(12, 2) // Minimum expense amount (exclusive)
  maxAmount         Decimal?           @db.Decimal(12, 2) // Maximum expense amount (inclusive)
  locationId        String? // Link to specific location
  location          InventoryLocation? @relation("LocationCondition", fields: [locationId], references: [id], onDelete: SetNull) // Changed relation name
  expenseCategoryId String? // Link to specific expense category
  expenseCategory   ExpenseCategory?   @relation(fields: [expenseCategoryId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations for Member and InventoryLocation
  members            Member[]            @relation("LocationConditions")
  inventoryLocations InventoryLocation[] @relation("InventoryLocationConditions")

  @@index([stepId])
  @@index([expenseCategoryId])
  @@index([locationId])
}

enum ConditionType {
  AMOUNT_RANGE // Based on minAmount/maxAmount
  EXPENSE_CATEGORY // Based on expenseCategoryId
  LOCATION // Based on locationId
  IS_REIMBURSABLE
  PROJECT
  HAS_RECEIPT
}

// Defines the required action (who needs to approve) for a step
model ApprovalStepAction {
  id     String               @id @default(cuid())
  stepId String
  step   ApprovalWorkflowStep @relation(fields: [stepId], references: [id], onDelete: Cascade)
  type   ApprovalActionType // Type of approver required

  approverRole     MemberRole? // Specific role required (e.g., MANAGER)
  specificMemberId String? // Specific member ID required
  specificMember   Member?     @relation("ApprovalStepActionMember", fields: [specificMemberId], references: [id], onDelete: SetNull) // SetNull: Action becomes invalid if member deleted

  // How multiple approvers (if any defined for the step) should act
  approvalMode ApprovalMode @default(ANY_ONE) // Requires ANY_ONE or ALL matching approvers

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stepId])
  @@index([specificMemberId])
}

enum ApprovalActionType {
  ROLE // Requires a member with a specific role
  SPECIFIC_MEMBER // Requires a specific member
  SUBMITTER_MANAGER
  // Add others like: SUBMITTER_MANAGER (requires the submitter's direct manager - needs hierarchy logic elsewhere)
}

enum ApprovalMode {
  ANY_ONE // Only one of the required approvers (matching type/role/id) needs to approve
  ALL // All members matching the criteria for this step must approve (more complex to implement tracking)
}

// Consider refining ApprovalStatus if needed, e.g., adding REQUEST_INFO

enum ApprovalStatus {
  PENDING // Awaiting approver action.
  APPROVED // Approver granted approval.
  REJECTED // Approver denied approval.
  REQUEST_CHANGES // Approver requests modification before approving.
  REQUEST_INFO // Approver requests additional information before approving.
}

model Budget {
  id          String   @id @default(cuid())
  name        String
  description String?
  amount      Decimal  @db.Decimal(10, 2)
  periodStart DateTime
  periodEnd   DateTime
  isActive    Boolean  @default(true)

  locationId     String?
  location       InventoryLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull)
  organizationId String
  organization   Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdById    String
  createdBy      Member             @relation(fields: [createdById], references: [id], onDelete: Restrict)

  departmentId        String?
  department          Department? @relation("DepartmentBudgets", fields: [departmentId], references: [id], onDelete: SetNull)
  activeForDepartment Department? @relation("DepartmentBudget") // If this budget is the 'active' one for a department
  expenses            Expense[]
  auditLogs           AuditLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fiscalYear Int? // Fiscal year this budget applies to
  variance   Decimal?       @db.Decimal(10, 2)
  reports    BudgetReport[]
  alerts     BudgetAlert[]

  @@unique([organizationId, name, periodStart, periodEnd])
  @@index([fiscalYear])
  @@index([departmentId])
  @@index([organizationId])
  @@index([isActive])
}

model BudgetReport {
  id            String   @id @default(cuid())
  budgetId      String
  budget        Budget   @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  reportDate    DateTime @default(now())
  periodStart   DateTime
  periodEnd     DateTime
  totalSpent    Decimal  @db.Decimal(10, 2)
  remaining     Decimal  @db.Decimal(10, 2)
  variance      Decimal  @db.Decimal(10, 2)
  notes         String?
  generatedById String
  generatedBy   Member   @relation(fields: [generatedById], references: [id], onDelete: Restrict)

  // Add index
  @@index([budgetId])
  @@index([reportDate])
}

model BudgetAlert {
  id         String   @id @default(cuid())
  budgetId   String
  budget     Budget   @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  threshold  Decimal  @db.Decimal(5, 2) // Percentage (e.g., 80 = 80% of budget)
  recipients String[] // Email addresses or member IDs to notify
  isActive   Boolean  @default(true)

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([budgetId])
  @@index([organizationId])
}

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

// Automation model for configuring automated tasks

enum TriggerType {
  SCHEDULE // Time-based trigger (daily, weekly, etc.)
  EVENT // Event-based trigger (e.g., low stock, new sale)
  CONDITION // Condition-based trigger (when certain conditions are met)
  MANUAL // Manually triggered by a user
  API // Triggered via API call
}

enum ActionType {
  CREATE_PURCHASE_ORDER // Create a purchase order for low stock items
  SEND_NOTIFICATION // Send notification to staff
  GENERATE_REPORT // Generate and send a report
  UPDATE_INVENTORY // Update inventory levels
  SEND_CUSTOMER_MESSAGE // Send message to customers
  ADJUST_PRICING // Adjust product pricing
  EXPORT_DATA // Export data to external system
  RUN_ANALYSIS // Run data analysis
  CUSTOM_ACTION // Custom action defined in actionConfig
}

// Logs for automation executions

model ExecutionLog {
  id           String          @id @default(cuid())
  executedAt   DateTime        @default(now())
  status       ExecutionStatus
  details      Json? // Details about the execution
  result       String? // Result of the execution
  errorMessage String? // Error message if failed

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  recurringExpenseId String?
  recurringExpense   RecurringExpense? @relation(fields: [recurringExpenseId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([executedAt])
  @@index([status])
}

enum ExecutionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}

model Notification {
  id          String           @id @default(cuid())
  type        NotificationType // e.g., "invitation", "mention", "announcement"
  title       String
  description String
  read        Boolean          @default(false)
  link        String? // Optional URL link associated with the notification
  createdAt   DateTime         @default(now())

  // --- Recipient ---
  // EITHER link to a registered User OR store the target email
  userId         String? // Foreign key for registered user
  recipientEmail String? // Email address for unregistered users/invitations

  // Relation to the User model (optional)
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade) // Optional: Cascade delete notifications if user is deleted

  // --- Sender Information (Optional) ---
  senderId String?
  member   Member? @relation(fields: [senderId], references: [id], onDelete: Cascade) // Optional: Cascade delete notifications if user is deleted

  expenseUserId  String? // Add this field
  userExpense    User?         @relation("UserExpenseNotifications", fields: [expenseUserId], references: [id], onDelete: Cascade)
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  // --- Type-Specific Details ---
  // Use a JSON field to store variable data based on notification type
  // Examples: { "organization": "Acme Corp", "role": "Developer" } for invitations
  //           { "meetingTime": "Tomorrow, 10:00 AM PST" } for reminders
  details        Json?

  // --- Indexes for Performance ---
  // Index for quickly finding notifications for a specific user
  // Index for finding notifications sent to a specific email
  // Index for filtering read/unread notifications
  // Index for sorting by creation time
  @@index([userId])
  @@index([recipientEmail])
  @@index([read])
  @@index([createdAt])
}

// Enum for Notification Types

enum NotificationType {
  INVITATION
  MENTION
  ANNOUNCEMENT
  REMINDER
  TASK_UPDATE
  SYSTEM_ALERT
  NEW_MEMBER
  WELCOME
  INVITATION_ACCEPTED
  INVITATION_DECLINED
  EXPENSE_SUBMITTED
  EXPENSE_APPROVAL
  EXPENSE_REJECTED
  EXPENSE_PAID
  BUDGET_ALERT
  BUDGET_THRESHOLD
}

model MpesaPaymentRequest {
  id                 String    @id @default(cuid())
  organizationId     String
  memberId           String
  checkoutRequestId  String
  merchantRequestId  String
  amount             Decimal
  phoneNumber        String
  reference          String
  status             String // PENDING, SUCCESS, FAILED
  resultCode         Int?
  resultDescription  String?
  mpesaReceiptNumber String?
  transactionDate    DateTime?
  saleData           Json? // Store the sale data for processing after successful payment
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  saleNumber         String?

  organization Organization @relation(fields: [organizationId], references: [id])
  member       Member       @relation(fields: [memberId], references: [id])

  @@index([organizationId])
  @@index([memberId])
  @@index([checkoutRequestId])
  @@index([merchantRequestId])
  @@index([reference])
}

model AttendanceLog {
  id                 String             @id @default(cuid())
  memberId           String
  member             Member             @relation(fields: [memberId], references: [id], onDelete: Cascade)
  organizationId     String
  organization       Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  checkInTime        DateTime
  checkOutTime       DateTime?
  checkInLocationId  String // Now references InventoryLocation
  checkInLocation    InventoryLocation  @relation("CheckInLocationLogs", fields: [checkInLocationId], references: [id], onDelete: Restrict)
  checkOutLocationId String? // Optional: if checkout can happen at a different location
  checkOutLocation   InventoryLocation? @relation("CheckOutLocationLogs", fields: [checkOutLocationId], references: [id], onDelete: Restrict)
  durationMinutes    Int? // Calculated when member checks out
  notes              String?
  isAutoCheckout     Boolean            @default(false) // To flag if this was an auto checkout
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  activeMemberCheckIn Member? @relation("ActiveCheckIn") // Link to Member's current active log

  @@index([memberId])
  @@index([organizationId])
  @@index([checkInTime])
  @@index([checkOutTime])
  @@index([checkInLocationId])
  @@map("attendance_log")
}

model Apikey {
  id                  String    @id
  name                String?
  start               String?
  prefix              String?
  key                 String
  userId              String
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  refillInterval      Int?
  refillAmount        Int?
  lastRefillAt        DateTime?
  enabled             Boolean?
  rateLimitEnabled    Boolean?
  rateLimitTimeWindow Int?
  rateLimitMax        Int?
  requestCount        Int?
  remaining           Int?
  lastRequest         DateTime?
  expiresAt           DateTime?
  createdAt           DateTime
  updatedAt           DateTime
  permissions         String?
  metadata            String?

  @@map("apikey")
}

// --- Authentication & Authorization Models --- (Mostly standard)

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Session {
  id             String   @id
  expiresAt      DateTime
  token          String   @unique
  createdAt      DateTime
  updatedAt      DateTime
  ipAddress      String?
  userAgent      String?
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy String?

  activeOrganizationId String?

  @@map("session")
}

// Organization-specific custom roles

model CustomRole {
  id             String       @id @default(cuid())
  name           String
  description    String?
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  permissions    String[] // Array of permission strings, e.g., ["product:create", "sale:view"]

  // For many-to-many with Member if a member can have multiple custom roles
  members  Member[] @relation("MemberCustomRoles")
  isActive Boolean  @default(true)

  isSystemRole Boolean  @default(false) // True for roles like "Cashier" if you want them modifiable
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([organizationId, name])
  @@map("custom_role")
}

model RoleTemplate {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "Store Manager", "Accountant"
  description String
  permissions String[] // Array of permission strings
  usageCount  Int      @default(0) // Tracks how many orgs use this template
  createdAt   DateTime @default(now())

  @@map("role_template")
}

enum Status {
  ONLINE
  OFFLINE
}

enum ChannelType {
  CHANNEL
  SUBCHANNEL
  DIRECT_MESSAGE
}

model Channel {
  id                 String      @id @default(cuid())
  name               String
  icon               String?
  type               ChannelType @default(CHANNEL)
  isGeneral          Boolean     @default(false)
  isPublic           Boolean     @default(true)
  isAssistantChannel Boolean     @default(false)
  createdAt          DateTime    @default(now())
  creatorId          String // Add foreign key field for creator
  creator            Member      @relation("ChannelCreator", fields: [creatorId], references: [id]) // Define relation with fields and references
  updatedAt          DateTime    @updatedAt

  messages        Message[]
  parent          Channel?        @relation("SubChannels", fields: [parentId], references: [id])
  parentId        String?
  subChannels     Channel[]       @relation("SubChannels")
  members         ChannelMember[] @relation("ChannelMembers")
  favoriteFor     Favorite[]
  linkedThreads   ThreadLink[]    @relation("SourceThread")
  linkedByThreads ThreadLink[]    @relation("TargetThread")

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  assistantId String?    @unique
  assistant   Assistant? @relation(fields: [assistantId], references: [id], onDelete: SetNull)

  assistantMessages AssistantMessage[]
  invitations       Invitation[] // Add relation for guest invitations

  // Add index for the foreign key
  @@index([organizationId])
  @@index([isPublic])
  @@index([isAssistantChannel])
  @@index([creatorId])
}

model ChannelMember {
  id        String   @id @default(cuid())
  memberId  String
  channelId String
  joinedAt  DateTime @default(now())
  member    Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)
  channel   Channel  @relation("ChannelMembers", fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([memberId, channelId])
  @@index([memberId])
  @@index([channelId])
}

// Message model: Represents individual chat messages.

model Message {
  id              String                  @id @default(cuid())
  content         String
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
  memberId        String // Changed from userId
  channelId       String
  sender          Member                  @relation(fields: [memberId], references: [id], onDelete: Cascade)
  channel         Channel                 @relation(fields: [channelId], references: [id], onDelete: Cascade)
  reactions       Reaction[]
  attachments     ChatMessageAttachment[]
  mentions        Mention[]
  hashtags        Hashtag[]
  parentMessage   Message?                @relation("Thread", fields: [parentMessageId], references: [id])
  parentMessageId String?
  replies         Message[]               @relation("Thread")

  @@index([memberId])
  @@index([channelId])
  @@index([parentMessageId])
}

// Reaction model: Represents emoji reactions to messages.

model Reaction {
  id        String   @id @default(cuid())
  emoji     String // The emoji character
  messageId String
  memberId  String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)

  // Ensure a user can only react once with the same emoji
  @@unique([messageId, memberId, emoji])
  @@index([messageId])
  @@index([memberId])
}

model ChatMessageAttachment {
  id        String  @id @default(cuid())
  name      String
  url       String // URL or path to the file
  type      String // File type (e.g., "image", "figma", "pdf")
  size      Int // Size in bytes
  messageId String
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  // Map to a clear table name
  @@index([messageId])
  @@map("chat_message_attachment")
}

// Mention model: Links messages to mentioned users.

model Mention {
  id        String  @id @default(cuid())
  messageId String
  memberId  String
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  member    Member  @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@unique([messageId, memberId])
  @@index([messageId])
  @@index([memberId])
}

model Hashtag {
  id       String    @id @default(cuid())
  tag      String    @unique // The hashtag text (e.g., #design)
  messages Message[] // Messages using this hashtag
}

// Favorite model: Links users to their favorite channels/DMs.

model Favorite {
  id        String  @id @default(cuid())
  userId    String
  channelId String
  user      Member  @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId])
  @@index([channelId])
}

// ThreadLink model: Represents links between channels (threads).

model ThreadLink {
  id             String @id @default(cuid())
  sourceThreadId String
  targetThreadId String

  sourceThread Channel @relation("SourceThread", fields: [sourceThreadId], references: [id], onDelete: Cascade)
  targetThread Channel @relation("TargetThread", fields: [targetThreadId], references: [id], onDelete: Cascade)

  @@unique([sourceThreadId, targetThreadId])
}

// --- Accounting Models (Revised for Simplicity & Robustness) ---

enum AccountClass {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  EXPENSE
}

model AccountType {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  name        String // e.g., "Current Asset", "Long-term Liability"
  class       AccountClass
  description String?

  accounts FinancialAccount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([organizationId, name])
  @@map("account_types")
}

model FinancialAccount {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  code        String
  name        String
  description String?

  accountTypeId String
  accountType   AccountType @relation(fields: [accountTypeId], references: [id], onDelete: Restrict)

  parentId String?
  parent   FinancialAccount?  @relation("AccountHierarchy", fields: [parentId], references: [id], onDelete: Restrict)
  children FinancialAccount[] @relation("AccountHierarchy")

  isActive     Boolean @default(true)
  currencyCode String  @default("USD")

  isControlAccount Boolean @default(false)

  journalEntries  JournalEntry[]
  reconciliations AccountReconciliation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([organizationId, code])
  @@unique([organizationId, name])
  @@index([organizationId, accountTypeId])
  @@map("accounts")
}

model FiscalPeriod {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  name      String
  code      String
  startDate DateTime
  endDate   DateTime
  status    PeriodStatus @default(OPEN)
  type      PeriodType   @default(MONTHLY)

  journals Journal[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([organizationId, code])
  @@map("fiscal_periods")
}

enum PeriodStatus {
  OPEN
  CLOSED
  LOCKED
}

enum PeriodType {
  MONTHLY
  QUARTERLY
  YEARLY
}

model Journal {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  reference   String
  description String
  date        DateTime
  postingDate DateTime?

  type           JournalType   @default(GENERAL)
  status         JournalStatus @default(DRAFT)
  fiscalPeriodId String
  fiscalPeriod   FiscalPeriod  @relation(fields: [fiscalPeriodId], references: [id], onDelete: Restrict)

  currencyCode String         @default("USD")
  entries      JournalEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  @@unique([organizationId, reference])
  @@index([organizationId, date, status])
  @@map("journals")
}

enum JournalType {
  GENERAL
  SALES
  PURCHASE
  CASH_RECEIPTS
  CASH_PAYMENTS
  ADJUSTING
  CLOSING
}

enum JournalStatus {
  DRAFT
  POSTED
  REVERSED
}

model JournalEntry {
  id        String  @id @default(cuid())
  journalId String
  journal   Journal @relation(fields: [journalId], references: [id], onDelete: Cascade)

  accountId String
  account   FinancialAccount @relation(fields: [accountId], references: [id], onDelete: Restrict)

  amount Decimal   @db.Decimal(15, 2)
  type   EntryType

  description String?

  lineNumber Int

  @@index([accountId])
  @@index([journalId])
  @@map("journal_entries")
}

enum EntryType {
  DEBIT
  CREDIT
}

model AccountReconciliation {
  id        String           @id @default(cuid())
  accountId String
  account   FinancialAccount @relation(fields: [accountId], references: [id])

  statementDate    DateTime
  statementBalance Decimal  @db.Decimal(15, 2)
  bookBalance      Decimal  @db.Decimal(15, 2)

  status ReconciliationStatus @default(PENDING)

  // Reconciliation details
  reconciledBy String?
  reconciledAt DateTime?
  notes        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("account_reconciliations")
}

enum ReconciliationStatus {
  PENDING
  IN_PROGRESS
  RECONCILED
  DISCREPANCY
}

model Report {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  type           ReportType
  data           Json
  summary        String?      @db.Text // For storing AI-generated summary
  startDate      DateTime
  endDate        DateTime
  generatedAt    DateTime     @default(now())
  generatedById  String
  generatedBy    Member       @relation(fields: [generatedById], references: [id])

  @@unique([organizationId, type, startDate, endDate])
  @@index([organizationId, type])
  @@map("reports")
}

enum ReportType {
  SALES_REPORT
  INVENTORY_REPORT
  EXPENSE_REPORT
}

model Subscription {
  id                   String       @id @default(cuid())
  organizationId       String       @unique
  organization         Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  dodoCustomerId       String?      @unique @map("dodo_customer_id")
  dodoSubscriptionId   String?      @unique @map("dodo_subscription_id")
  dodoPriceId          String?      @map("dodo_price_id")
  dodoCurrentPeriodEnd DateTime?    @map("dodo_current_period_end")

  @@map("subscriptions")
}

model Jwks {
  id         String   @id
  publicKey  String
  privateKey String
  createdAt  DateTime

  @@map("jwks")
}

model ReferralProgram {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String
  description    String?
  isActive       Boolean      @default(true)
  referrerReward Int // Points awarded to the referrer
  refereeReward  Int // Points awarded to the new user (referee)
  rewardType     String       @default("points") // e.g., points, discount, etc.
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  referrals      Referral[]

  @@unique([organizationId, name])
  @@map("referral_program")
}

model Referral {
  id             String          @id @default(cuid())
  organizationId String
  organization   Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  referrerId     String // The User who made the referral
  referrer       User            @relation("ReferredBy", fields: [referrerId], references: [id], onDelete: Cascade)
  refereeId      String          @unique // The new User who was referred
  referee        User            @relation("ReferredUser", fields: [refereeId], references: [id], onDelete: Cascade)
  programId      String
  program        ReferralProgram @relation(fields: [programId], references: [id])

  // UPDATED: More descriptive status
  status String @default("pending_verification") // e.g., pending_verification, verified, first_purchase_completed

  // NEW: Track if the first purchase has been made to prevent duplicate point awards
  firstPurchaseMade Boolean @default(false)

  rewardApplied Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([referrerId])
  @@index([refereeId])
  @@map("referral")
}

// --- Loyalty System Models ---

model LoyaltyPointsConfig {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // UPDATED: More specific action types
  actionType LoyaltyActionType

  points      Int // The number of points to award for the action
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([organizationId, actionType])
  @@map("loyalty_points_config")
}

model LoyaltyProgram {
  id              String        @id @default(cuid())
  organizationId  String        @unique
  organization    Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name            String
  pointsPerDollar Float         @default(1) // How many points are earned per dollar spent
  redemptionRate  Float         @default(0.01) // How much one point is worth in dollars
  isActive        Boolean       @default(true)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  tiers           LoyaltyTier[]

  @@map("loyalty_program")
}

model LoyaltyTier {
  id              String         @id @default(cuid())
  programId       String
  program         LoyaltyProgram @relation(fields: [programId], references: [id], onDelete: Cascade)
  name            String // e.g., Bronze, Silver, Gold
  minPoints       Int // Minimum points to enter this tier
  pointMultiplier Float          @default(1.0) // e.g., 1.2x points for Gold members
  benefits        String[] // Array of text descriptions of benefits
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  customers       Customer[]

  @@unique([programId, name])
  @@map("loyalty_tier")
}

model LoyaltyTransaction {
  id              String            @id @default(cuid())
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  customerId      String
  customer        Customer          @relation(fields: [customerId], references: [id], onDelete: Cascade) // Cascade if customer deleted
  memberId        String // Changed from userId
  member          Member            @relation(fields: [memberId], references: [id], onDelete: Restrict) // Prevent member deletion if they issued points
  pointsChange    Int // Positive for earned, negative for redeemed
  actionType      LoyaltyActionType @default(SALE_EARNED)
  relatedSaleId   String?           @unique // Link to the sale that earned/used points
  relatedSale     Sale?             @relation(fields: [relatedSaleId], references: [id], onDelete: SetNull) // Keep record if sale deleted
  notes           String?
  transactionDate DateTime          @default(now())

  // Added Organization relation for data isolation/querying
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([transactionDate])
  @@index([memberId])
  @@index([organizationId])
}

enum LoyaltyActionType {
  SALE_EARNED // Points earned from a purchase
  REDEMPTION // Points spent on a purchase or reward
  MANUAL_ADJUSTMENT // Admin adjustment (correction, bonus)
  PROMOTION // Points awarded from a specific promotion
  SIGN_UP_BONUS // Points for new customer registration
  RETURN_ADJUSTMENT // Points deducted due to a returned item
  BIRTHDAY_BONUS // Points awarded for customer's birthday
  REFERRAL_BONUS // Points for referring a new customer
  REFERRAL_FIRST_PURCHASE // Points for referring a new customer
  REFERRAL_SIGNUP_VERIFIED // Points for referring a new customer
  OTHER // Miscellaneous reasons
}

model Driver {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  memberId       String       @unique // Link to the Member model
  member         Member       @relation(fields: [memberId], references: [id], onDelete: Cascade)

  availability    DriverStatus @default(OFFLINE)
  currentLocation String? // Could be lat/long
  phone           String

  vehicleId String?  @unique
  vehicle   Vehicle? @relation(fields: [vehicleId], references: [id], onDelete: SetNull)

  deliveries Delivery[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@map("driver")
}

/**
 * Represents a vehicle used for deliveries.
 */
model Vehicle {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  driver Driver?

  make         String // e.g., "Toyota"
  model        String // e.g., "Corolla"
  licensePlate String      @unique
  color        String?
  type         VehicleType @default(CAR)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@map("vehicle")
}

/**
 * Represents a single delivery instance.
 * Linked to an order.
 */
model Delivery {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  orderId String @unique
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  driverId String?
  driver   Driver? @relation(fields: [driverId], references: [id], onDelete: SetNull)

  status DeliveryStatus @default(PENDING)

  // Addresses
  pickupAddress   Json // From restaurant/location
  deliveryAddress Json // To customer

  // Timestamps
  assignedAt            DateTime? // When a driver is assigned
  pickedUpAt            DateTime? // When the driver picks up the order
  deliveredAt           DateTime? // When the order is delivered
  estimatedDeliveryTime DateTime?

  deliveryFee   Decimal @default(0) @db.Decimal(10, 2)
  driverNotes   String?
  customerNotes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([driverId])
  @@index([status])
  @@map("delivery")
}

// --- Enums to add to your schema.prisma ---

enum DriverStatus {
  ONLINE // Available for deliveries
  OFFLINE // Not available
  ON_DELIVERY // Currently on a delivery
}

enum VehicleType {
  MOTORCYCLE
  CAR
  VAN
  BICYCLE
}

enum DeliveryStatus {
  PENDING // Waiting for a driver
  ACCEPTED // Driver has accepted the delivery
  PICKING_UP // Driver is on the way to the restaurant
  AT_PICKUP // Driver has arrived at the restaurant
  IN_TRANSIT // Order has been picked up and is on its way
  DELIVERED // Order has been delivered to the customer
  CANCELLED // Delivery was cancelled
  FAILED_DELIVERY // Delivery attempt failed
}
